###
Original CrashKit code Copyright (c) 2009 Andrey Tarantsov, YourSway LLC (http://crashkitapp.appspot.com/)
Copyright (c) 2010 Colin Snover (http://zetafleet.com)
Copyright (c) 2012 Onur Can Cakmak <onur.cakmak@gmail.com>

Released under the ISC License.
http://opensource.org/licenses/isc-license.txt
###
class TraceKit
  "use strict"

  # Properties
  collectWindowErrors: true
  debug: false
  handlers: []
  lastException: null
  lastExceptionStack: null
  oldOnErrorHandler: null
  remoteFetching: true
  sourceCache: {}

  # Internal functions

  ###
  Adds information about the first frame to incomplete stack traces.
  Safari and IE require this to get complete data on the first frame.
  @param {Object.<string, *>} stackInfo Stack trace information from one of the compute* methods.
  @param {string} url The URL of the script that caused an error.
  @param {(number|string)} lineNo The line number of the script that caused an error.
  @param {string=} message The error generated by the browser, which hopefully contains the name of the object that caused the error.
  @return {boolean} Whether or not the stack information was augmented.
  ###
  _augmentStackTraceWithInitialElement = (stackInfo, url, lineNo, message) ->
    initial =
      url: url
      line: lineNo

    if initial.url and initial.line
      stackInfo.incomplete = false
      initial.func = _guessFunctionName(initial.url, initial.line) unless initial.func
      initial.context = _gatherContext(initial.url, initial.line) unless initial.context
      reference = new RegExp(" '([^']+)' ").exec(message)
      initial.column = _findSourceInLine(reference[1], initial.url, initial.line) if reference
      if stackInfo.stack.length > 0
        if stackInfo.stack[0].url is initial.url
          if stackInfo.stack[0].line is initial.line
            return false # already in stack trace
          else if not stackInfo.stack[0].line and stackInfo.stack[0].func is initial.func
            stackInfo.stack[0].line = initial.line
            stackInfo.stack[0].context = initial.context
            return false
      stackInfo.stack.unshift initial
      stackInfo.partial = true
      return true
    else
      stackInfo.incomplete = true
    return false

  ###
  Computes a stack trace for an exception.
  @param {Error} ex
  @param {(string|number)=} depth
  ###
  _computeStackTrace = (ex, depth) ->
    stack = null
    depth = if depth? then +depth else 0
    try
      # This must be tried first because Opera 10 *destroys*
      # its stacktrace property if you try to access the stack
      # property first!!
      stack = _computeStackTraceFromStacktraceProp(ex)
      return stack if stack
    catch e
      throw e if @debug

    try
      stack = _computeStackTraceFromStackProp(ex)
      return stack if stack
    catch e
      throw e if @debug

    try
      stack = _computeStackTraceFromOperaMultiLineMessage(ex)
      return stack if stack
    catch e
      throw e if @debug

    try
      stack = _computeStackTraceByWalkingCallerChain(ex, depth + 1)
      return stack if stack
    catch e
      throw e if @debug

    return (
      mode: "failed"
    )

  ###
  Computes stack trace information by walking the arguments.caller
  chain at the time the exception occurred. This will cause earlier
  frames to be missed but is the only way to get any stack trace in
  Safari and IE. The top frame is restored by {@link augmentStackTraceWithInitialElement}.
  @param {Error} ex
  @return {?Object.<string, *>} Stack trace information.
  ###
  _computeStackTraceByWalkingCallerChain = (ex, depth) ->
    functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i
    stack = []
    funcs = {}
    recursion = false
    parts = undefined
    item = undefined
    source = undefined
    curr = _computeStackTraceByWalkingCallerChain.caller

    while curr and not recursion

      # console.log('skipping internal function');
      continue if curr is _computeStackTrace or curr is @report
      item =
        url: null
        func: "?"
        line: null
        column: null

      if curr.name
        item.func = curr.name
      else item.func = parts[1] if parts = functionName.exec(curr.toString())
      if source = _findSourceByFunctionBody(curr)
        item.url = source.url
        item.line = source.line
        item.func = _guessFunctionName(item.url, item.line) if item.func is "?"
        reference = new RegExp(" '([^']+)' ").exec(ex.message or ex.description)
        item.column = _findSourceInLine(reference[1], source.url, source.line) if reference
      if funcs["" + curr]
        recursion = true
      else
        funcs["" + curr] = true
      stack.push item
      curr = curr.caller

    # console.log('depth is ' + depth);
    # console.log('stack is ' + stack.length);
    stack.splice 0, depth if depth
    result =
      mode: "callers"
      name: ex.name
      message: ex.message
      url: document.location.href
      stack: stack
      useragent: navigator.userAgent

    _augmentStackTraceWithInitialElement result, ex.sourceURL or ex.fileName, ex.line or ex.lineNumber, ex.message or ex.description
    return result

  ###
  NOT TESTED.
  Computes stack trace information from an error message that includes the stack trace.
  Opera 9 and earlier use this method if the option to show stack traces is turned on in opera:config.
  @param {Error} ex
  @return {?Object.<string, *>} Stack information.
  ###
  _computeStackTraceFromOperaMultiLineMessage = (ex) ->
    # Opera includes a stack trace into the exception message. An example is:
    #
    # Statement on line 3: Undefined variable: undefinedFunc
    # Backtrace:
    #   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz
    #         undefinedFunc(a);
    #   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy
    #           zzz(x, y, z);
    #   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx
    #           yyy(a, a, a);
    #   Line 1 of function script
    #     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }
    #   ...
    lines = ex.message.split("\n")
    return null if lines.length < 4
    lineRE1 = /^\s*Line (\d+) of linked script ((?:file|http|https)\S+)(?:: in function (\S+))?\s*$/i
    lineRE2 = /^\s*Line (\d+) of inline#(\d+) script in ((?:file|http|https)\S+)(?:: in function (\S+))?\s*$/i
    lineRE3 = /^\s*Line (\d+) of function script\s*$/i
    stack = []
    scripts = document.getElementsByTagName("script")
    inlineScriptBlocks = []
    parts = undefined
    i = undefined
    len = undefined
    source = undefined
    for i of scripts
      inlineScriptBlocks.push scripts[i] if TraceKit._has(scripts, i) and not scripts[i].src
    i = 2
    len = lines.length

    while i < len
      item = null
      if parts = lineRE1.exec(lines[i])
        item =
          url: parts[2]
          func: parts[3]
          line: +parts[1]
      else if parts = lineRE2.exec(lines[i])
        item =
          url: parts[3]
          func: parts[4]

        relativeLine = (+parts[1]) # relative to the start of the <SCRIPT> block
        script = inlineScriptBlocks[parts[2] - 1]
        if script
          source = _getSource(item.url)
          if source
            source = source.join("\n")
            pos = source.indexOf(script.innerText)
            item.line = relativeLine + source.substring(0, pos).split("\n").length if pos >= 0
      else if parts = lineRE3.exec(lines[i])
        url = window.location.href.replace(/#.*$/, "")
        line = parts[1]
        re = new RegExp(_escapeCodeAsRegExpForMatchingInsideHTML(lines[i + 1]))
        source = _findSourceInUrls(re, [url])
        item =
          url: url
          line: (if source then source.line else line)
          func: ""
      if item
        item.func = _guessFunctionName(item.url, item.line)  unless item.func
        context = _gatherContext(item.url, item.line)
        midline = ((if context then context[Math.floor(context.length / 2)] else null))
        if context and midline.replace(/^\s*/, "") is lines[i + 1].replace(/^\s*/, "")
          item.context = context
        else

          # if (context) alert("Context mismatch. Correct midline:\n" + lines[i+1] + "\n\nMidline:\n" + midline + "\n\nContext:\n" + context.join("\n") + "\n\nURL:\n" + item.url);
          item.context = [lines[i + 1]]
        stack.push item
      i += 2
    return null unless stack.length # could not parse multiline exception message as Opera stack trace
    return (
      mode: "multiline"
      name: ex.name
      message: lines[0]
      url: document.location.href
      stack: stack
      useragent: navigator.userAgent
    )

  ###
  Computes stack trace information from the stack property.
  Chrome and Gecko use this property.
  @param {Error} ex
  @return {?Object.<string, *>} Stack trace information.
  ###
  _computeStackTraceFromStackProp = (ex) ->
    return null unless ex.stack
    chrome = /^\s*at ((?:\[object object\])?\S+) \(((?:file|http|https):.*?):(\d+)(?::(\d+))?\)\s*$/i
    gecko = /^\s*(\S*)(?:\((.*?)\))?@((?:file|http|https).*?):(\d+)(?::(\d+))?\s*$/i
    lines = ex.stack.split("\n")
    stack = []
    parts = undefined
    element = undefined
    reference = /^(.*) is undefined$/.exec(ex.message)
    i = 0
    j = lines.length

    while i < j
      if parts = gecko.exec(lines[i])
        element =
          url: parts[3]
          func: parts[1]
          args: (if parts[2] then parts[2].split(",") else "")
          line: +parts[4]
          column: (if parts[5] then +parts[5] else null)
      else if parts = chrome.exec(lines[i])
        element =
          url: parts[2]
          func: parts[1]
          line: +parts[3]
          column: (if parts[4] then +parts[4] else null)
      else
        continue
      element.func = _guessFunctionName(element.url, element.line) if not element.func and element.line
      element.context = _gatherContext(element.url, element.line) if element.line
      stack.push element
      ++i
    stack[0].column = _findSourceInLine(reference[1], stack[0].url, stack[0].line) if stack[0] and stack[0].line and not stack[0].column and reference

    return null unless stack.length
    return (
      mode: "stack"
      name: ex.name
      message: ex.message
      url: document.location.href
      stack: stack
      useragent: navigator.userAgent
    )

  ###
  Computes stack trace information from the stacktrace property.
  Opera 10 uses this property.
  @param {Error} ex
  @return {?Object.<string, *>} Stack trace information.
  ###
  _computeStackTraceFromStacktraceProp = (ex) ->
    # Access and store the stacktrace property before doing ANYTHING
    # else to it because Opera is not very good at providing it
    # reliably in other circumstances.
    stacktrace = ex.stacktrace
    testRE = new RegExp(" line (\\d+), column (\\d+) in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\) in (.*):\\s*$", "i")
    lines = stacktrace.split("\n")
    stack = []
    parts = undefined
    i = 0
    j = lines.length

    while i < j
      if parts = testRE.exec(lines[i])
        element =
          line: +parts[1]
          column: +parts[2]
          func: parts[3] or parts[4]
          args: (if parts[5] then parts[5].split(",") else [])
          url: parts[6]

        element.func = _guessFunctionName(element.url, element.line) if not element.func and element.line
        if element.line
          try
            element.context = _gatherContext(element.url, element.line)
        element.context = [lines[i + 1]]  unless element.context
        stack.push element
      i += 2
    return null unless stack.length
    return (
      mode: "stacktrace"
      name: ex.name
      message: ex.message
      url: document.location.href
      stack: stack
      useragent: navigator.userAgent
    )

  ###
  Logs a stacktrace starting from the previous call and working down.
  @param {(number|string)=} depth How many frames deep to trace.
  @return {Object.<string, *>} Stack trace information.
  ###
  _computeStackTraceOfCaller = (depth) ->
    depth = (if depth? then +depth else 0) + 1 # "+ 1" because "ofCaller" should drop one frame
    try
      throw new Error()
    catch ex
      return _computeStackTrace ex, depth + 1
    return null

  ###
  Escapes special characters in a string to be used inside a regular
  expression as a string literal. Also ensures that HTML entities will
  be matched the same as their literal friends.
  @param {string} body The string.
  @return {string} The escaped string.
  ###
  _escapeCodeAsRegExpForMatchingInsideHTML = (body) ->
    _escapeRegExp(body).replace("<", "(?:<|&lt;)").replace(">", "(?:>|&gt;)").replace("&", "(?:&|&amp;)").replace("\"", "(?:\"|&quot;)").replace(/\s+/g, "\\s+")

  ###
  Escapes special characters, except for whitespace, in a string to be
  used inside a regular expression as a string literal.
  @param {string} text The string.
  @return {string} The escaped string literal.
  ###
  _escapeRegExp = (text) ->
    text.replace /[\-\[\]{}()*+?.,\\\^$|#]/g, "\\$&"

  ###
  Extends support for global error handling for asynchronous browser
  functions. Adopted from Closure Library's errorhandler.js
  ###
  _extendToAsynchronousCallbacks = (w) ->
    _helper = _helper = (fnName) ->
      originalFn = w[fnName]
      w[fnName] = traceKitAsyncExtension = ->

        # Make a copy of the arguments
        args = Array::slice.call arguments, 0
        originalCallback = args[0]
        if typeof (originalCallback) is "function"
          args[0] = traceKitArgsZero = ->
            try
              originalCallback.apply this, arguments
            catch e
              TraceKit.report e
              throw e

        # IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it
        # also only supports 2 argument and doesn't care what "this" is, so we
        # can just call the original function directly.
        if originalFn.apply
          originalFn.apply this, args
        else
          originalFn args[0], args[1]

    _helper "setTimeout"
    _helper "setInterval"

  ###
  Determines where a function was defined within the source code.
  @param {(Function|string)} func A function reference or serialized function definition.
  @return {?Object.<string, (string|number)>} An object containing the url, line, and column number of the defined function.
  ###
  _findSourceByFunctionBody = (func) ->
    urls = [window.location.href]
    scripts = document.getElementsByTagName("script")
    body = undefined
    code = "" + func
    codeRE = /^function(?:\s+([\w$]+))?\s*\(([\w\s,]*)\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/
    eventRE = /^function on([\w$]+)\s*\(event\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/
    re = undefined
    parts = undefined
    result = undefined
    i = 0

    while i < scripts.length
      script = scripts[i]
      urls.push script.src if script.src
      ++i
    unless parts = codeRE.exec(code)
      re = new RegExp(_escapeRegExp(code).replace(/\s+/g, "\\s+"))

    # not sure if this is really necessary, but I don?t have a test
    # corpus large enough to confirm that and it was in the original.
    else
      name = (if parts[1] then "\\s+" + parts[1] else "")
      args = parts[2].split(",").join("\\s*,\\s*")
      body = _escapeRegExp(parts[3]).replace(/;$/, ";?") # semicolon is inserted if the function ends with a comment.replace(/\s+/g, '\\s+');
      re = new RegExp("function" + name + "\\s*\\(\\s*" + args + "\\s*\\)\\s*{\\s*" + body + "\\s*}")

    # look for a normal function definition
    return result if result = _findSourceInUrls(re, urls)

    # look for an old-school event handler function
    if parts = eventRE.exec(code)
      event = parts[1]
      body = _escapeCodeAsRegExpForMatchingInsideHTML(parts[2])

      # look for a function defined in HTML as an onXXX handler
      re = new RegExp("on" + event + "=[\\'\"]\\s*" + body + "\\s*[\\'\"]", "i")
      return result if result = _findSourceInUrls(re, urls[0])

      # look for ???
      re = new RegExp(body)
      return result if result = _findSourceInUrls(re, urls)
    return null

  ###
  Determines at which column a code fragment occurs on a line of the source code.
  @param {string} fragment The code fragment.
  @param {string} url The URL to search.
  @param {(string|number)} line The line number to examine.
  @return {?number} The column number.
  ###
  _findSourceInLine = (fragment, url, line) ->
    source = _getSource(url)
    re = new RegExp("\\b" + _escapeRegExp(fragment) + "\\b")
    m = undefined
    line -= 1
    return m.index if source and source.length > line and (m = re.exec(source[line]))
    null

  ###
  Determines where a code fragment occurs in the source code.
  @param {RegExp} re The function definition.
  @param {Array.<string>} urls A list of URLs to search.
  @return {?Object.<string, (string|number)>} An object containing the url, line, and column number of the defined function.
  ###
  _findSourceInUrls = (re, urls) ->
    source = undefined
    m = undefined
    i = 0
    j = urls.length

    while i < j
      # console.log('searching', urls[i]);
      if (source = _getSource(urls[i])).length
        source = source.join("\n")
        if m = re.exec(source)

          # console.log('Found function in ' + urls[i]);
          return (
            url: urls[i]
            line: source.substring(0, m.index).split("\n").length
            column: m.index - source.lastIndexOf("\n", m.index) - 1
          )
      ++i

    # console.log('no match');
    return null

  ###
  Retrieves the surrounding lines from where an exception occurred.
  @param {string} url URL of source code.
  @param {(string|number)} line Line number in source code to centre around for context.
  @return {?Array.<string>} Lines of source code.
  ###
  _gatherContext = (url, line) ->
    source = _getSource url
    context = []
    hasContext = false
    return null unless source.length
    line -= 1 # convert to 0-based index
    i = line - 2
    j = line + 2

    while i < j
      context.push source[i]
      hasContext = true if source[i]?
      ++i
    (if hasContext then context else null)

  ###
  Retrieves source code from the source code cache.
  @param {string} url URL of source code.
  @return {Array.<string>} Source contents.
  ###
  _getSource = (url) ->
    return @sourceCache[url] if _has @sourceCache, url

    # URL needs to be able to fetched within the acceptable domain.  Otherwise,
    # cross-domain errors will be triggered.
    source = undefined
    if url.indexOf(document.domain) isnt -1
      source = _loadSource(url)
    else
      source = []
    return @sourceCache[url] = (if source.length then source.split("\n") else [])

  ###
  Tries to use an externally loaded copy of source code to determine the name of a function by looking at the
  name of the variable it was assigned to, if any.
  @param {string} url URL of source code.
  @param {(string|number)} lineNo Line number in source code.
  @return {string} The function name, if discoverable.
  ###
  _guessFunctionName = (url, lineNo) ->
    reFunctionArgNames = /function ([^(]*)\(([^)]*)\)/
    reGuessFunction = /['"]?([0-9A-Za-z$_]+)['"]?\s*[:=]\s*(function|eval|new Function)/
    line = ""
    maxLines = 10
    source = _getSource(url)
    m = undefined
    return "?" unless source.length

    # Walk backwards from the first line in the function until we find the line which
    # matches the pattern above, which is the function definition
    i = 0

    while i < maxLines
      line = source[lineNo - i] + line
      if line?
        if m = reGuessFunction.exec(line)
          return m[1]
        else return m[1] if m = reFunctionArgNames.exec(line)
      ++i
    return "?"

  ###
  TraceKit._has, a better form of hasOwnProperty
  Example: TraceKit._has(MainHostObject, property) === true/false
  @param {Object} host object to check property
  @param {string} key to check
  ###
  _has = (object, key) ->
    Object::hasOwnProperty.call object, key

  ###
  Attempts to retrieve source code via XMLHttpRequest, which is used
  to look up anonymous function names.
  @param {string} url URL of source code.
  @return {string} Source contents.
  ###
  _loadSource = (url) ->
    #Only attempt request if remoteFetching is on.
    return "" unless @remoteFetching
    try
      # IE 5.x-6.x
      if typeof XMLHttpRequest is "undefined"
        XMLHttpRequestWrapper = IEXMLHttpRequestSub = ->
          try
            return new ActiveXObject("Msxml2.XMLHTTP.6.0")
          try
            return new ActiveXObject("Msxml2.XMLHTTP.3.0")
          try
            return new ActiveXObject("Msxml2.XMLHTTP")
          try
            return new ActiveXObject("Microsoft.XMLHTTP")
          throw new Error("No XHR.")
      else
        XMLHttpRequestWrapper = XMLHttpRequest
      request = new XMLHttpRequestWrapper()
      request.open "GET", url, false
      request.send ""
      return request.responseText
    catch e
      return ""

  ###
  Dispatch stack information to all handlers.
  @param {Object.<string, *>} stack
  ###
  _notifyHandlers = (stack, isWindowError) ->
    exception = null
    return if !@collectWindowErrors and isWindowError? and isWindowError

    for h in @handlers
      if _has @handlers, h
        try
          @handlers[h] stack
        catch innerException
          expcetion = innerException

    throw exception if exception?
    return

  ###
  Extended support for backtraces and global error handling for most
  asynchronous jQuery functions.
  ###
  _traceKitAsyncForjQuery = ($) ->
    _oldEventAdd = $.event.add
    $.event.add = traceKitEventAdd = (elem, types, handler, data, selector) ->
      _handler = undefined
      if handler.handler
        _handler = handler.handler
        handler.handler = traceKitHandler = ->
          try
            return _handler.apply this, arguments
          catch e
            TraceKit.report e
            throw e
      else
        _handler = handler
        handler = apply_handler = ->
          try
            return _handler.apply this, arguments
          catch e
            TraceKit.report e
            throw e

      # If the handler we are attaching doesn?t have the same guid as
      # the original, it will never be removed when someone tries to
      # unbind the original function later. Technically as a result of
      # this our guids are no longer globally unique, but whatever, that
      # never hurt anybody RIGHT?!
      if _handler.guid
        handler.guid = _handler.guid
      else
        handler.guid = _handler.guid = $.guid++
      _oldEventAdd.call this, elem, types, handler, data, selector

    _oldReady = $.fn.ready
    $.fn.ready = traceKitjQueryReadyWrapper = (fn) ->
      _fn = ->
        try
          return fn.apply this, arguments
        catch e
          TraceKit.report e
          throw e

      _oldReady.call this, _fn

    _oldAjax = $.ajax
    $.fn.ajax = traceKitAjaxWrapper = (s) ->
      if $.isFunction s.complete
        _oldComplete = s.complete
        s.complete = traceKitjQueryComplete = ->
          try
            return _oldComplete.apply this, arguments
          catch e
            TraceKit.report e
            throw e
      if $.isFunction s.error
        _oldError = s.error
        s.error = traceKitjQueryError = ->
          try
            return _oldError.apply this, arguments
          catch e
            TraceKit.report e
            throw e
      if $.isFunction s.success
        _oldSuccess = s.success
        s.success = traceKitjQuerySuccess = ->
          try
            return _oldSuccess.apply this, arguments
          catch e
            TraceKit.report e
            throw e
      try
        return _oldAjax.call this, s
      catch e
        TraceKit.report e
        throw e

  ###
  Ensures all global unhandled exceptions are recorded.
  Supported by Gecko and IE.
  @param {string} message Error message.
  @param {string} url URL of script that generated the exception.
  @param {(number|string)} lineNo The line number at which the error occurred.
  ###
  _traceKitWindowOnErrorHandler = (message, url, lineNo) ->
    stack = null
    if @lastExceptionStack?
      _augmentStackTraceWithInitialElement @lastExceptionStack, url, lineNo, message
      stack = @lastExceptionStack
      @lastExceptionStack = null
      @lastException = null
    else
      location =
        "url": url
        "line": lineNo
        "func": _guessFunctionName url, lineNo
        "context": _gatherContext url, lineNo
      stack =
        "mode": "onerror"
        "message": message
        "url": document.location.href
        "stack": [location]
        "useragent": navigator.userAgent

    _notifyHandlers stack, true

    return @oldOnErrorHandler.apply this, arguments if @oldOnErrorHandler
    false

  # Public functions
  augmentStackTraceWithInitialElement: _augmentStackTraceWithInitialElement
  computeStackTraceOfCaller: _computeStackTraceOfCaller
  gatherContext: _gatherContext
  guessFunctionName: _guessFunctionName

  ###
  Reports an unhandled Error to TraceKit.
  @param {Error} ex
  ###
  report: (ex) ->
    if @lastExceptionStack?
      return if @lastException is ex
    else
      s = @lastExceptionStack
      @lastExceptionStack = null
      @lastException = null
      _notifyHandlers s

    stack = _computeStackTrace ex
    @lastExceptionStack = stack
    @lastException = ex

    ###
    If the stack trace is incomplete, wait for 2 seconds for
    slow slow IE to see if onerror occurs or not before reporting
    this exception; otherwise, we will end up with an incomplete
    stack trace
    ###
    window.setTimeout( =>
      if @lastException is ex
        @lastExceptionStack = null
        @lastException = null
        _notifyHandlers stack
    , if stack.incomplete then 2000 else 0)

    throw ex

  ###
  Add an error handler.
  @param {Function} handler
  ###
  subscribe: (handler) ->
    @handlers.push handler

  ###
  Remove a crash handler.
  @param {Function} handler
  ###
  unsubscribe: (handler) ->
    for i in [0..@handlers.length]
      @handlers.splice i, 1 if @handlers[i] == handler
    return

  constructor: (options) ->
    _extendToAsynchronousCallbacks window
    _traceKitAsyncForjQuery window.jQuery if window.jQuery?
    window.onerror = _traceKitWindowOnErrorHandler

    @collectWindowErrors = options.collectWindowErrors if options.collectWindowErrors?
    @oldOnErrorHandler = window.onerror
    @remoteFetching = options.remoteFetching if options.remoteFetching?
